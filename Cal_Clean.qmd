---
title: "Cal_Clean: A Script for Tidying Sable Indirect Calorimetry Data"
author: "Chelsea Faber"
format: 
   html:
     df-print: paged
editor: visual
---

## About

###### Inputs:

-   Cohort and rundate of calorimetry run
-   List of animal ID numbers to be excluded (NA if none)

###### Outputs:

-   .Rda file containing cleaned dataframe at original sampling rate (typically, 1-3 minutes), 1h-binned dataframe, and photoperiod-binned dataframes for further plotting and statistical analyses.

###### Requirements:

-   TimeSeries sheet from Macro-processed .exp data files (MI \< v2.46) in 1 or 3-minute bins
-   TimeSeries sheet as a .csv saved in your default working directory (run `library(here)` to find out where this is!)
-   Group decoding sheet with same prefix as TimeSeries sheet (e.g., expID_date_code.csv), saved in same directory

###### Known bugs:

-   EnviroLightlux_M is inconsistent in numbering (sometimes has 0s and 1s, or 1s and 3s, or 3s and 7s), therefore photoperiod assignment is done based on ZT/clock time and NOT from sensor. This will need to be updated for DD or other light schedule experiments

## Load required packages

```{r}
#| label: load-packages
#| warning: false
#| echo: false
library(plyr, include.only = 'mapvalues')
library(tidyverse)
library(magrittr)
library(lubridate)
library(here)
```

## Define inputs to script for analysis

If everything is working properly, these variables are the only ones a user should have to change to clean a given file's calorimetry data. Eventually, this entire script will be converted to a function, such that the user would type these in-line when calling that function (e.g., `Cal_Clean(cohort = 'mon001',rundate = '2021-10-18',remove_animals = 274)`).

```{r}
# Run-specific user-defined parameters
cohort          <- "CAL009"
rundate         <- "2022-07-11"  
remove_animals  <- NA

# Default parameters. For diet, temperature, or other interventions, set the value of intervention equal to TRUE.
intervention    <- FALSE
segment.run     <- FALSE
cols2excl       <- c('Still_pct_M','Sleep_pct_M',
                     'XBreak_R','YBreak_R','Mass_g','AllMeters_M')
```

## More parameters, depending on inputs

```{r}
# insert if/then statements for diet.change, temp.change, and intervention (prompt user to give date/time of change) - for diet, also prompt for starting diet, ending diet


```

## Load data

To load your data, please ensure that it is located in the repository that the `here()` function points to. Otherwise, you will get an error.

A workaround, if you do not wish to load your data using the here() package, is to type the entire file path in the call to `read_csv()`.

```{r}
#| warning: false
#| code-overflow: wrap
filename        <- paste(rundate,cohort,sep = "_")
code            <- paste(rundate,cohort,"DECODED",sep = "_")

# Load csv with run metadata
df_code         <- read_csv(here::here(paste(code,".csv",sep = ""))) 
df_code

# Load cal.csv and merge metadata
df              <- read_csv(here::here(paste(filename,".csv",sep = ""))) %>%
  left_join(df_code, by = "Animal") %>%                 #unblind by merging with decoding df 
  mutate(across(.cols = everything()),na_if(.,".")) %>% #replace "." with "NA"
  rename(Cage = Animal)%>%
  select(!(starts_with("Enviro") 
           | starts_with("Ped") 
           | all_of(cols2excl)))
```

## Tidy data

Here, we remove any animals that we had previously specified, and perform some general data cleaning - most importantly, extraction of time of day information from the DateTime column.

```{r}
#| warning: false

# Remove dead/sick animals; if NA, don't run
if (!is.na(remove_animals)) {
   df %<>%
    filter(ID_Code != remove_animals)
}

# Parse date-times and sort by animal ID (ID_Code) and date-time
df %<>% 
  relocate(c(DateTime,Sex,Group,Treatment,Cohort,ID_Code)) %>%
  mutate(DateTime = round_date(ymd_hms(df$DateTime),unit = "minute")) %>%
  mutate(month = as.numeric(month(DateTime)),
         day = as.numeric(day(DateTime)),
         hour = as.numeric(hour(DateTime)),
         minute = as.numeric(minute(DateTime))) 

df <- df[order(df$DateTime),] %>%
  arrange(ID_Code)

# Remove any rows/columns with only NAs
df <- df[rowSums(is.na(df)) != ncol(df), ]
df <- df[, colSums(is.na(df)) != nrow(df)]
```

## Transform data

Here, we first filter the data so that all recordings begin and end at ZT12 (18:00). Next we compute a handful of new variables from the original DateTime, including Zeitgeber time, Photoperiod, and experimental day.

```{r}
# Extract original date-time information
og.start         <- head(df$DateTime, n=1)
og.end           <- last(df$DateTime)
og.dur           <- og.end - og.start

# Find index of first lights out (18:00) for each animal
df %<>% group_by(ID_Code)
idx.start        <- which(hour(df$DateTime) == 18)[1]-1
time.start       <- as.POSIXct(df$DateTime[idx.start])

# Trim everything before first lights out
df %<>%
  filter(DateTime > time.start)

# Find index of last lights out
idx.end          <- tail(which(hour(df$DateTime) == 17), n=1) + 1
time.end         <- as.POSIXct(df$DateTime[idx.end])

# Trim everything after last lights out
df %<>% 
  filter(DateTime < time.end)

# Compute ZT time, rename some variables
df %<>%
  mutate(ZT = plyr::mapvalues(hour, 
                              from = (0:23), 
                              to = c(18:23,0:17)),.before = Sex) %>% 
  mutate(Photoperiod = as.factor(
    plyr::mapvalues(ZT, 
                    from = c(0:23), 
                    to = c(rep(1,12),rep(0,12)))),.before = ZT) %>%
  rename(VO2 = VO2_M,
         Animal = ID_Code,
         VCO2 = VCO2_M,
         EE = kcal_hr_M,
         RER = RER_M,
         FoodIn.cum = FoodInA_M,
         WaterIn.cum = WaterInA_M,
         AllMeters = AllMeters_R,
         BodyMass = BodyMass_Mnz,
         VH2O = VH2O_M)

# Compute experimental day (ExpDay) and elapsed time (Time) in hours
df %<>% 
  mutate(ExpDay = as.integer(ceiling(difftime(DateTime,time.start, units = "days"))),
         Time = as.numeric(difftime(DateTime,time.start), units = "hours"),
         .after = DateTime) %>%
  ungroup()

# Calculate rolling Age, from the starting Age entered in the "DECODED" metadata file.
if ("Age" %in% colnames(df)) {
  df %<>% 
    group_by(ExpDay,Animal) %>% 
    mutate(Age = ExpDay-1 + first(Age)) %>% 
    ungroup()
} else {
  print("No Age values found in DECODED. If this is in error, please revised DECODED sheet accordingly, save, and rerun script, otherwise, continue.")
}

# Recompute cumulative variables to begin at new start time
df %<>%
  group_by(Animal) %>% 
  mutate(FoodIn.cum = FoodIn.cum - first(FoodIn.cum),
         WaterIn.cum = WaterIn.cum - first(WaterIn.cum)) %>% 
  ungroup()
```

Next, we will compute some more parameters of interest, including binned food and water intake (from the original cumulative values), food intake in kcal (from grams), binned and cumulative energy expenditure (from the instantaneous estimate of hourly rate), cumulative distance traveled, and energy balance. The binned energy expenditure is questionable currently - please let me know if you find any issues.

```{r}
# Compute time interval (in hours) for estimating binned energy expenditure
int <- df$Time[2] - df$Time[1]

# Compute daily average for body mass
df %<>%
  group_by(Animal, ExpDay) %>%
  mutate(meanBodyMass = mean(BodyMass),.after = BodyMass) %>%
  ungroup()

# Detect diet from df_code and establish conversion
if (sum(is.na(df_code$Diet)) ==length(df_code$Diet)) {
  print('No diet type specified in DECODED file. Assigning default of chow (4.2 kcal/g). If this is in error, please revised the DECODED file and re-run the script from the beginning.')
  df %<>% 
    mutate(Diet = "NCD")
}
  
# Compute new columns
df %<>%
  group_by(Animal) %>%
  mutate(FoodIn.g = c(diff(FoodIn.cum),0),.before = FoodIn.cum) %>% # convert cumulative to binned food intake
  mutate(WaterIn.g = c(diff(WaterIn.cum),0),.before = WaterIn.cum) %>% # convert cumulative to binned water intake
  mutate(FoodIn.kcal = case_when(
    Diet == "NCD" ~ FoodIn.g * 3.35,
    Diet == "HFD" ~ FoodIn.g * 5.47),
    .before = FoodIn.g) %>% # convert g to kcal
  mutate(FoodIn.cum.kcal = cumsum(FoodIn.kcal),.after = FoodIn.cum) %>%
  mutate(EE.kcal.bin = EE * int, .before = EE) %>% # EE is kcal/hr, multiply by int (x hours between samples) to get kcal/bin
  mutate(EE.cum = cumsum(EE.kcal.bin), .before = EE.kcal.bin) %>%
  mutate(EBalance = FoodIn.kcal - EE.kcal.bin, .before = VO2) %>% # compute energy balance per bin
  mutate(EB.cum = cumsum(EBalance), .after = EBalance) %>%
  mutate(AllMeters.cum = cumsum(AllMeters),.before = AllMeters) %>% # compute cumulative distance traveled
  ungroup()

# Compute measures normalized to body weight
cols2norm <- c('FoodIn.kcal','FoodIn.cum.kcal','EE','EE.cum','EBalance',
               'EB.cum')

df %<>% 
  group_by(Animal) %>% 
  mutate(across(all_of(cols2norm),
                ~ . / meanBodyMass,
         .names = "norm.{.col}")) %>% 
    ungroup()

# Trim last row with mostly NAs, created during some transformations above
df <- head(df,-1)
```

## Bin to hourly

Here, we compute hourly bins for each variable. Depending on variable, this is done by either summing all values within the hour (`cols2sum`: binned, non-cumulative measures), taking the mean of all values within the hour (`cols2avg`: rates), taking the maximum value within the hour (`cols4cum`: binned, cumulative measures), and taking the median value for assigning the new bin time (`cols2med`: dates and times only).

```{r}
#/ warning: false

# DO NOT CHANGE WITHOUT EXPRESS PERMISSION FROM CHELSEA!!!!!!!!!!
cols2sum <- c('norm.FoodIn.kcal','FoodIn.g','FoodIn.kcal','WaterIn.g','EBalance','norm.EBalance','AllMeters')
cols2avg <- c('VO2','VCO2','VH2O','EE','RER','BodyMass','meanBodyMass','norm.EE')
cols4cum <- c('AllMeters.cum','FoodIn.cum','WaterIn.cum','EE.cum','norm.EE.cum','EB.cum','norm.EB.cum','FoodIn.cum.kcal','norm.FoodIn.cum.kcal')
cols2med <- c('DateTime','Time','minute')

# Bin to hourly! 
df.hourly <- df %>%
  group_by(Animal,ExpDay,hour) %>%
  select(!EE.kcal.bin) %>% # don't need the 1-3" bin anymore
  mutate(
    across(all_of(cols2med),median)) %>% # assign middle of time bin to new bin
  mutate(across(
    all_of(cols2avg), mean)) %>% # rates get averaged
  mutate(across(
    all_of(cols2sum),sum)) %>% # intake, distances get summed
  mutate(across(
    all_of(cols4cum),last)) %>% # cumulative values just keep the maximum (total for the hour)
  ungroup() %>%
  distinct() %>% # squashes down to one observation per hour
  select(!c(hour,minute,month,day)) %>% 
  mutate(Animal = as.factor(Animal)) %>%
  group_by(Animal) %>%
  #slice(2:(n()-1)) %>% # trim incomplete hours at start and end
  mutate(DateTime = round_date(DateTime, "30 minutes")) %>% 
  mutate(Time = as.numeric(
    difftime(DateTime,DateTime[1]),units = "hours"),.after = DateTime) %>% # starts clock from 0 at start of recording
  ungroup()
```

## Photoperiod and daily means

Next, we compute the cumulative totals or averages of all variables for each experimental day.

***Note that the experimental day is derived from the calendar day.***

If incomplete days were not trimmed above, then the daily and photoperiod averages will be affected by the start and end of recording where \<24-hours are included. Working on a fix for this, where each day starts from the start of the recording (day 1 = first 24 hours, and so on).

```{r}
#/ warning: false
# Compute averages/totals for each day
total.avg.daily <- df %>%
  group_by(Animal,ExpDay) %>% 
  summarize(
    across(all_of(cols2sum),sum),
    across(all_of(cols2avg),mean),
    across(all_of(cols4cum), ~ last(.) - first(.))) %>%
  mutate(Photoperiod = "Total") %>%
  ungroup() 
```

Next, we compute cumulative totals or averages of all variables within each photoperiod per day. This is merged with the `total.avg.daily` data so that plots containing dark, light, and total can be obtained from the same data frame.

```{r}
#/ warning: false
# Compute average within each photoperiod, append to total.avg.daily
daily.pp.avg <- df %>%
  group_by(Animal,ExpDay,Photoperiod) %>%
  summarize(
    across(all_of(cols2sum),sum),
    across(all_of(cols2avg),mean),
    across(all_of(cols4cum), ~ last(.) - first(.))) %>% 
  ungroup() %>%
  bind_rows(.,total.avg.daily) %>% 
  left_join(df_code, by = c("Animal" = "ID_Code")) %>% 
  select(-Animal.y)
rm(total.avg.daily)
daily.pp.avg
```

Finally, we compute cumulative totals and averages across the entire experiment, for each day...

```{r}
#/ warning: false
# Compute each animal's average/total per variable for entire experiment
exp.avg <- df %>%
  group_by(Animal) %>%
  summarize(
    across(all_of(cols2sum),sum),
    across(all_of(cols2avg),mean),
    across(all_of(cols4cum), ~ last(.))) %>% 
  mutate(Photoperiod = "Total") %>% 
  ungroup()
```

... and within each photoperiod.

```{r}
#/ warning: false
# Compute the overall average daily value for every requested variable across the whole experiment
exp.pp.avg <- daily.pp.avg %>%
  group_by(Animal, Photoperiod) %>%
  summarize(
    across(all_of(cols2sum), sum),
    across(all_of(cols2avg), mean),
    across(all_of(cols4cum), sum)) %>% 
  ungroup() %>%
  bind_rows(., exp.avg) %>% 
  left_join(df_code, by = c("Animal" = "ID_Code")) %>% 
  select(-Animal.y)

rm(exp.avg)
exp.pp.avg
```

## Save data

```{r}
savename <- paste(rundate,cohort,"Clean.Rda",sep = "_")
save(df, df.hourly, daily.pp.avg, exp.pp.avg, df_code, file = savename)
rm(list = ls())
```
