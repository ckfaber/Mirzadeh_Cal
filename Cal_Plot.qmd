---
title: "Cal_Plot: A Script for Plotting Tidied Sable Indirect Calorimetry Data"
author: "Chelsea Faber"
format: 
   html:
     df-print: paged
editor: visual
---

###### Inputs:

-   Cohort and rundate for macro-processed, Cal_Clean-tidied .Rda file

###### Outputs:

-   Many plots! Many options for plots! The more you tell me what you need, the more I can make this do automatically. For now, I tried best to anticipate things we would always want to peek at, but this can easily be expanded.

###### Requirements:

The following files must be saved in your default working directory (run `library(here)` to find out where this is!)

-   .Rda file output from Cal_Clean.R. This contains cleaned dataframe at original sampling rate (typically, 1-3 minutes), 1h-binned dataframe, and photoperiod-binned dataframes for further plotting and statistical analyses.

###### Known bugs:

-   No flag for recording days with fewer than 24h - may misrepresent day/photoperiod total data
-   By default does not plot smoothed variables - fix so if smooth \<- TRUE, smoothed variables calculated AND plotted

###### To do:

-   Normalize various measures by body weight

-   Convert to function? Must decide on best user-provided function ins and outs

-   Statistical analyses in separate function/script? Look to CalR paper for code reference on ANCOVA. If stats done in separate function, how best to annotate significance?

## Load packages

```{r}
#| warning: false
library(plyr, include.only = 'mapvalues')
library(tidyverse)
library(patchwork)
library(here)
```

## Define inputs to script for analysis

```{r}
#| warning: false
cohort           <- "mon001"
rundate          <- "2021-10-18"

# Specify grouping & list of variables for smoothing via moving mean
group            <- 'Treatment'
smooth           <- TRUE
cols2smooth      <- c('VO2','VCO2','VH2O','EE','RER','BodyMass')

# Defaults
tsvars           <- c('EE','EBalance','RER','AllMeters.cum','FoodIn.cum',
                      'WaterIn.cum','FoodIn.kcal','BodyMass')
boxplotvars      <- c('EE','EBalance','RER','AllMeters','WaterIn.g',
                      'FoodIn.kcal')
```

## Load data

```{r}
#| warning: false
load(here::here(paste(cohort,rundate,"Clean.Rda",sep = "_")))
```

If you look in your R environment, you should see a few new objects have appeared - `df`,`df.hourly`,`pp.avg.daily`, and `pp.avg.total`. These are the data frames we created using Cal_Clean.R. Take a peek using `View(object)` to be sure they're what you expect. Here we'll just view the top 6 rows for the sake of space.

```{r}
head(pp.avg.daily)
```

To make our lives easier in annotating our plots with the appropriate units and titles for each variable, load in the "Cal_Units.csv" file containing a list of all abbreviated variables, and the corresponding units and full names.

```{r}
#| warning: false
unitkeys         <- read_csv(here::here("Cal_Units.csv"))
unitkeys
```

OK, let's start getting plots together. First we have some more tidying to do... 

## (Optional) Smoothing via moving mean 
Sometimes, the 1-hr binned data looks very messy. Here we can optionally employ smoothing via a moving mean to denoise the plots. This code section will run if `smooth <- TRUE`. If `smooth <- FALSE`, it will not run.

```{r}
#| warning: false
if (smooth) {
  smooth_win <- 3 # in hours
  df.hourly %<>%
  group_by(Animal) %>% 
  mutate(across(
    all_of(cols2smooth) , 
    ~ zoo::rollmean(., smooth_win, fill = NA), 
    .names = "smooth{smooth_win}_{.col}" )) %>%
  ungroup()  
}
```
Let's visualize one variable from a single animal to see the difference that smoothing makes. First, the unsmoothed:
```{r}
ggplot(data = filter(df.hourly, Animal == 276)) + 
  geom_line(mapping = aes(x = Time, y = RER))
```
Now the smoothed:
```{r}
#| warning: false
ggplot(data = filter(df.hourly, Animal == 276)) + 
  geom_line(mapping = aes(x = Time, y = smooth3_RER))
```

## Timeseries plots
The following code creates some functions to help us automatically generate timeseries plots for the variables  specified in `tsvars`. 

We want to generate timeseries plots wherein a line connects the means of the grouping variable (specified in `group`), and the SEM is shaded above and below the mean line. To do this, we need to generate some summary reports for each variable. First, we create the following function:
```{r}
#| warning: false
# Create function to generate hourly summaries by variable
group_summarize <- function(group,var) {
  df.hourly %>% 
    group_by( get(group) ,Time) %>% 
    summarize(
      value = mean( get(var) ), 
      sd = sd( get(var) ), 
      n = n(), 
      sem = sd(get(var)) / sqrt(n()), .groups = "drop") %>% 
    rename( {{group}} := "get(group)") 
  }
```
`group_summarize()` requires two inputs: `group` and `var`. To the `df.hourly` dataframe, `group_summarize` first groups the data by this grouping variable and by `Time`, then summarizes the mean value, the standard deviation, the number of observations within the group, and the standard error of the mean (sem). 

Let's try it out on one variable and one grouping to make sure it works. 
```{r}
group_summarize("Sex","EE")
```

Now, loop through all variables in `tsvars` and run this function. We'll store the result in a list called `grp.summaries`. Run `View(grp.summaries)` to see the structure. You can access the individual data frames within this list by using the `$` indexing syntax, for example, `grp.summaries$RER`.
```{r}
#| warning: false
# initialize empty list
grp.summaries     <- vector(mode = "list", length = length(tsvars)) # initialize empty list
for (i in 1:length(tsvars)) {
  
  var <- tsvars[i]
  names(grp.summaries)[i] <- var
  grp.summaries[[i]] <- group_summarize(group,var)

}
grp.summaries$RER
```
Almost ready to plot, but we need a couple more things to make sure we can automate the plot generation and make them pretty. 

First, let's extract the photoperiod information - this will allow us to have shaded boxes corresponding to dark cycle, and light boxes corresponding to the light cycle. 
```{r}
#| warning: false
# Extract time-series as small df for plotting
pp_data <- df.hourly %>%
  distinct(Time,Photoperiod)
head(pp_data)
```
Okay last step - let's write a function that will generate our plots for us! We want them to all look the same, but automatically have the correct title and x-axis labels. The following function, `group_tsplot()`, (should) accomplish this. If it looks busy, imagine having to copy/paste this 10x for each of your variables!
```{r}
# Create function to generate time-series plots
tsplot <- function(data,group,title,ylab) {
  
  plot <- ggplot(data) + 
    
    # Shaded light/dark boxes
    geom_tile(data = pp_data,
              mapping = aes(fill = Photoperiod,y=0),
              alpha = 0.2,
              height = Inf,
              show.legend = NA) + # tiles will go all the way up and down
    aes(x = Time, y = value) +
    geom_line(aes(color = get(group))) + 
    
    # Set color scheme
    scale_color_manual(group,values = c("turquoise4", "darkorange3")) +   # colors for the group
    
    # Smooth SEM ribbon 
    geom_ribbon(aes(
      ymin = value-sem, 
      ymax = value+sem,
      fill = get(group)),
      linetype = 0,
      alpha = 0.3)+
    
    # Set color scheme for filled areas: light/dark boxes and SEM ribbon
    scale_fill_manual(values = c("0" = "gray45","1" = "white","chABC" = "turquoise4","HIchABC" = "darkorange3"),guide = "none") +   
    labs(x = "Time (hours)", y = ylab)+ 
    scale_x_continuous(expand = expansion(0, 0)) +   # no padding on the x-axis
    theme_classic() + 
    ggtitle(title)
  
}
```
Let's break down what this function does. The first line `tsplot <- function(data,group,title,ylab)` indicates our function requires 4 inputs: `data`, `group`, `title`, and `ylab`. 

Let's test this "manually" on one set of data before we loop through all of `tsvars` again. 
```{r}

```
