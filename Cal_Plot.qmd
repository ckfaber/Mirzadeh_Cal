---
title: "Cal_Plot: A Script for Plotting Tidied Sable Indirect Calorimetry Data"
author: "Chelsea Faber"
format: 
   html:
     df-print: paged
     embed-resources: true
editor: visual
---

###### Inputs:

-   Cohort and rundate for macro-processed, Cal_Clean-tidied .Rda file

###### Outputs:

-   Many plots! Many options for plots! The more you tell me what you need, the more I can make this do automatically. For now, I tried best to anticipate things we would always want to peek at, but this can easily be expanded.

###### Requirements:

The following files must be saved in your default working directory (run `library(here)` to find out where this is!)

-   .Rda file output from Cal_Clean.R. This contains cleaned dataframe at original sampling rate (typically, 1-3 minutes), 1h-binned dataframe, and photoperiod-binned dataframes for further plotting and statistical analyses.

###### Known bugs:

-   No flag for recording days with fewer than 24h - may misrepresent day/photoperiod total data
-   By default does not plot smoothed variables - fix so if smooth \<- TRUE, smoothed variables calculated AND plotted

###### To do:

-   Use group_by() then nest() then map() to improve speed of looping through variables

-   Batch saving/exporting vector graphic files of plots

-   When generating grp.summaries list, currently other possibly desired groupings (e.g., Diet, Cohort, Sex) are omitted. Will revise so that they are included if faceting by other groupings is desired.

-   Normalize various measures by body weight

-   Convert to function? Must decide on best user-provided function ins and outs

-   Statistical analyses in separate function/script? Look to CalR paper for code reference on ANCOVA. If stats done in separate function, how best to annotate significance?

## Load packages

```{r}
#| warning: false
#| echo: false
library(plyr, include.only = 'mapvalues')
library(tidyverse)
library(ggnewscale)
library(patchwork)
library(here)
```

## Define inputs to script for analysis

```{r}
#| warning: false
cohort           <- "CAL009"
rundate          <- "2022-07-11"

# Specify grouping & list of variables for smoothing via moving mean
group            <- c('Group')
saveraw          <- FALSE
export           <- 'all' # set to 'all','ts', 'box', or 'none'

# Defaults
smooth           <- TRUE
norm             <- TRUE
tsvars           <- c('VO2','VCO2','VH2O','EE','EE.cum','EBalance','RER',
                      'AllMeters.cum','FoodIn.cum','WaterIn.cum',
                      'FoodIn.kcal','BodyMass')
boxvars      <- c('VO2','EE','EBalance','RER','AllMeters','WaterIn.g',
                      'FoodIn.kcal')

if (norm) {
  boxvars         <- c(boxvars,'norm.EB.cum','norm.EE.cum','norm.EE','norm.FoodIn.cum.kcal')
}

if (smooth) {
  smoothvars         <- sapply(tsvars,paste0,"_smooth3", USE.NAMES = FALSE)
} 
```

## Load data

```{r}
#| warning: false
load(here::here(paste(rundate,cohort,"Clean.Rda",sep = "_")))
```

If you look in your R environment, you should see a few new objects have appeared - `df`,`df.hourly`,`pp.avg.daily`, and `pp.avg.total`. These are the data frames we created using Cal_Clean.R. Take a peek using `View(object)` to be sure they're what you expect. Here we'll just view the top 6 rows for the sake of space.

```{r}
head(daily.pp.avg)
```

To make our lives easier in annotating our plots with the appropriate units and titles for each variable, load in the "Cal_Units.csv" file containing a list of all abbreviated variables, and the corresponding units and full names.

```{r}
#| warning: false
unitkeys         <- read_csv(here::here("Cal_Units.csv"))
```

OK, let's start getting plots together. First we have some more tidying to do...

## Timeseries plots

The following code creates some functions to help us automatically generate timeseries plots for the variables specified in `tsvars`.

We want to generate timeseries plots wherein a line connects the means of the grouping variable (specified in `group`), and the SEM is shaded above and below the mean line. To do this, we need to generate some summary reports for each variable. First, we create the following function:

```{r}
#| warning: false
# Create function to generate hourly summaries by variable
group_summarize <- function(group,var) {
  df.hourly %>% 
    group_by( get(group) ,Time) %>% 
    summarize(
      value = mean( get(var) ), 
      sd = sd( get(var) ), 
      n = n(), 
      sem = sd(get(var)) / sqrt(n()), .groups = "drop") %>% 
    rename( {{group}} := "get(group)") 
  }
```

`group_summarize()` requires two inputs: `group` and `var`. To the `df.hourly` dataframe, `group_summarize` first groups the data by this grouping variable and by `Time`, then summarizes the mean value, the standard deviation, the number of observations within the group, and the standard error of the mean (sem).

Let's try it out on one variable and one grouping to make sure it works.

```{r}
group_summarize("Sex","EBalance")
```

Now, loop through all variables in `tsvars` and run this function. We'll store the result in a list called `grp.summaries`. Run `View(grp.summaries)` to see the structure. You can access the individual data frames within this list by using the `$` indexing syntax, for example, `grp.summaries$RER`.

```{r}
#| warning: false
# initialize empty list

grp.summaries     <- vector(mode = "list", length = length(tsvars)) # initialize empty list
  
for (i in 1:length(tsvars)) {
  var <- tsvars[i]
  names(grp.summaries)[i] <- var
  grp.summaries[[i]] <- group_summarize(group,var)
}

# Calculate moving mean for each variable
if (smooth) {
  smooth_win <- 3 # in hours
  for (i in 1:length(tsvars)) {
    grp.summaries[[i]] %<>% 
      group_by(get(group)) %>%
      mutate(across(c(value,sd,sem),
                    ~ zoo::rollmean(.,smooth_win, 
                                    fill = NA, 
                                    align = "center"),
                    .names = "{.col}_smooth{smooth_win}")) %>%
      ungroup() %>% 
      select(!`get(group)`)
  }
}
```

Almost ready to plot, but we need a couple more things to make sure we can automate the plot generation and make them pretty.

First, let's extract the photoperiod information - this will allow us to have shaded boxes corresponding to dark cycle, and light boxes corresponding to the light cycle.

```{r}
#| warning: false
# Extract time-series as small df for plotting
pp_data <- df.hourly %>%
  distinct(Time,Photoperiod)
```

Okay last step - let's write some functions that will generate our plots for us! We want them to all look the same, but automatically have the correct title and x-axis labels. The following functions, `tsplot()` and `tsmoothplot()`, (should) accomplish this. If it looks busy, imagine having to copy/paste this 10x for each of your variables!

First, create general time-series plotting function:

```{r}
# Create function to generate time-series plots
tsplot <- function(data,group,title,ylab) {
  
  plot <- ggplot(data) + 
    
    # Line plots connecting means by grouping variable
    aes(x = Time, y = value) +
    geom_line(aes(color = get(group))) +
    scale_colour_brewer(group, palette = "Dark2") +
    
    # Smooth SEM ribbon 
    geom_ribbon(aes(
      ymin = value-sem, 
      ymax = value+sem,
      fill = get(group)),
      linetype = 0,
      alpha = 0.3)+
    
    # Set fill colors for SEM ribbon
    scale_fill_brewer(aesthetics = "fill", 
                      palette = "Dark2", 
                      guide = "none") +
    
    # Shaded tiles for photoperiod
    new_scale_fill() +
    geom_tile(data = pp_data, 
              mapping = aes(x = Time, fill = Photoperiod,y=0),
                alpha = 0.2,
                height = Inf, # tiles will go all the way up and down
                show.legend = NA,
            inherit.aes = FALSE) + 
    scale_fill_manual(values = c("0" = "gray45",
                               "1" = "white"),guide = "none") +
    
    # Plot annotations and formatting
    labs(x = "Time (hours)", y = ylab)+ 
    scale_x_continuous(expand = expansion(0, 0)) +   # no padding on the x-axis
    theme_classic() + 
    ggtitle(title) 
}
```

Next, create smoothed time-series plotting function:

```{r}
# Create function to generate smoothed time-series plots
tsmoothplot <- function(data,group,title,ylab) {
  
  plot <- ggplot(data) + 
    
    # Line plots connecting means by grouping variable
    aes(x = Time, y = value_smooth3) +
    geom_line(aes(color = get(group))) +
    scale_colour_brewer(group, palette = "Dark2") +
    
    # Smooth SEM ribbon 
    geom_ribbon(aes(
      ymin = value_smooth3-sem_smooth3, 
      ymax = value_smooth3+sem_smooth3,
      fill = get(group)),
      linetype = 0,
      alpha = 0.3)+
    
    # Set fill colors for SEM ribbon
    scale_fill_brewer(aesthetics = "fill", 
                      palette = "Dark2", 
                      guide = "none") +
    
    # Shaded tiles for photoperiod
    new_scale_fill() +
    geom_tile(data = pp_data, 
              mapping = aes(x = Time, fill = Photoperiod,y=0),
                alpha = 0.2,
                height = Inf, # tiles will go all the way up and down
                show.legend = NA,
            inherit.aes = FALSE) + 
    scale_fill_manual(values = c("0" = "gray45",
                               "1" = "white"),guide = "none") +
    
    # Plot annotations and formatting
    labs(x = "Time (hours)", y = ylab)+ 
    scale_x_continuous(expand = expansion(0, 0)) +   # no padding on the x-axis
    theme_classic() + 
    ggtitle(title) 
}
```

Now let's loop through `tsvars` again and generate plots for all of our variables of interest. We'll store the resulting ggplot objects in a list called `ts.plots`, so we can access or print out the individual plots using `$` indexing, as before with our grp.summaries.

```{r}
#| warning: false
# Loop through ggplot generation 
ts.plots <- vector(mode = "list",length = length(tsvars))

for (i in 1:length(tsvars)) {
  
  data <- grp.summaries[[i]]
  var <- names(grp.summaries)[i]
  
  title <- mapvalues(var, from = unitkeys$Renamed_Var, to = unitkeys$Title, warn_missing = FALSE)
  unit <- mapvalues(var, from = unitkeys$Renamed_Var, to = unitkeys$Unit, warn_missing = FALSE)
  
  if (is.na(unit)) ylab <- title else ylab <- paste(title,unit)
  
  ts.plots[[i]] <- tsplot(data,group,title,ylab)
  names(ts.plots)[i] <- var
  print(ts.plots[[i]])
  
}
```

Repeat for variables in `smoothvars`, storing resulting plots in `tsmooth.plots`.

```{r}
#| warning: false
# Loop through ggplot generation 
tsmooth.plots <- vector(mode = "list",length = length(smoothvars))

for (i in 1:length(smoothvars)) {
  
  data <- grp.summaries[[i]]
  var <- smoothvars[i]
  
  title <- mapvalues(var, from = unitkeys$Renamed_Var, to = unitkeys$Title, warn_missing = FALSE)
  unit <- mapvalues(var, from = unitkeys$Renamed_Var, to = unitkeys$Unit, warn_missing = FALSE)
  
  if (is.na(unit)) ylab <- title else ylab <- paste(title,unit)
  
  tsmooth.plots[[i]] <- tsmoothplot(data,group,title,ylab)
  names(tsmooth.plots)[i] <- var
  print(tsmooth.plots[[i]])
  
}
```

## Box Plots (D/L/total for daily and overall experiment)

Now, we'll use the same approach as above to generate box and whisker plots for dark/light/total values for each variable in `boxplotvars`. First, we'll create a function, `bxplot()`, that generates plots how we'd like them to look:

```{r}
# Create function to generate boxplots
bxplot <- function(data,group,var,title,ylab) {
  
  ggplot(data,
         aes(x = Photoperiod,
             y = get(var))) +
    geom_boxplot(aes(fill = stage(get(group), after_scale = alpha(fill, 0.5)))) +
    scale_color_manual(group,
      values = c("turquoise4", "darkorange3"),
      aesthetics = c("color", "fill")
    ) +
    labs(x = NULL, y = ylab) +
    scale_x_discrete(labels = c("Dark", "Light", "Total")) +
    theme_classic() + 
    ggtitle(title)
  
}
```

```{r}
# Create function to generate boxplots
bxplot <- function(data,group,var,title,ylab) {
  
  ggplot(data,
         aes(x = Photoperiod,
             y = get(var))) +
    geom_boxplot(aes(fill = stage(get(group), after_scale = alpha(fill, 0.5)))) +
    scale_color_brewer(group,
      palette = "Dark2",
      aesthetics = c("color", "fill")
    ) +
    labs(x = NULL, y = ylab) +
    scale_x_discrete(labels = c("Dark", "Light", "Total")) +
    theme_classic() + 
    ggtitle(title)
  
}
```

Now, we can loop through `boxplotvars`. First, let's make box plots for the entire experiment, saving them in a list called `box.plots`.

```{r}
# Loop through all variables for overall experiment plots
box.plots <- vector(mode = "list",length = length(boxvars))
for (i in 1:length(boxvars)) {
  
  var <- boxvars[i]
  
  title <- mapvalues(var, from = unitkeys$Renamed_Var, to = unitkeys$Title, warn_missing = FALSE)
  unit <- mapvalues(var, from = unitkeys$Renamed_Var, to = unitkeys$Unit, warn_missing = FALSE)
  
  if (is.na(unit)) ylab <- title else ylab <- paste(title,unit)
  
  names(box.plots)[i] <- var
  plot <- bxplot(data = exp.pp.avg,group = group,var = var,title = title,ylab = ylab)
  print(plot)
  
  box.plots[[i]] <- plot
}
```

Now let's make daily box plots, saving in a list called `daily.box.plots`...these are much busier, but may be useful to evaluate qualitatively for any day-specific effects.

```{r}
# Loop through all the variables for daily plots
daily.boxplots <- vector(mode = "list",length = length(boxvars))
for (i in 1:length(boxvars)) {
  
  var <- boxvars[i]
  
  title <- mapvalues(var, from = unitkeys$Renamed_Var, to = unitkeys$Title, warn_missing = FALSE)
  unit <- mapvalues(var, from = unitkeys$Renamed_Var, to = unitkeys$Unit, warn_missing = FALSE)
  
  if (is.na(unit)) ylab <- title else ylab <- paste(title,unit)
  
  names(daily.boxplots)[i] <- var
  plt <- bxplot(data = daily.pp.avg,group = group,var = var,title = title,ylab = ylab) + 
    facet_grid(cols = vars(ExpDay))
  print(plt)
  
  daily.boxplots[[i]] <- plt
}
```

## Assemble figures

From here, you can either export your plots into your desired format to assemble figures elsehwere (Lighroom, Photoshop, Powerpoint, God forbid). Or, you can play around with the `patchwork` library, which can arrange panels and labels for you in an intuitive syntax.

```{r}
Figure1 <- ts.plots$EE / ts.plots$RER
Figure1 +
  plot_layout(ncol = 1, guides = "collect") +
  plot_annotation(
    title = "Figure 1. Neonatal digestion of PNNs does stuff!",
    caption = "from cohort mon001",
    tag_levels = "a"
  )
```

There are a few kinks to be worked out with font sizing and spacing, but it's pretty powerful!

```{r}
Figure2 <- box.plots$EE + box.plots$RER
Figure2 +
  plot_layout(guides = "collect") + 
  plot_annotation(title = "Figure 2. Photoperiod-averaged data is cool",
                  tag_levels = "a")
```

## Save & Export figures

```{r}
if (saveraw) {
  savename <- paste(rundate,cohort,group,"Plots.Rda",sep = "_")
  save(grp.summaries,ts.plots,tsmooth.plots,box.plots, file = savename)
}
```
